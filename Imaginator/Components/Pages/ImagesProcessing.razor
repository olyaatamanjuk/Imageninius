@page "/images-processing"
@rendermode InteractiveServer

@using System.Collections.Generic
@using System.Net.Http.Headers
@using System.Text
@using System.Text.Json


@inject IHttpClientFactory ClientFactory

<h3>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å</h3>

<!-- –í–∏–±—ñ—Ä —Ñ–∞–π–ª—ñ–≤ -->
<div class="mb-3">
    <label for="fileInput" class="form-label">–û–±–µ—Ä—ñ—Ç—å —Ñ–∞–π–ª–∏ –∞–±–æ —Ç–µ–∫—É:</label>
    <InputFile id="fileInput" multiple class="form-control" OnChange="HandleSelectedFiles" @key="FileInputKey" />
</div>

<!-- –ö–Ω–æ–ø–∫–∏ -->
<div>
    <button class="btn btn-primary" @onclick="ProcessImages">–û–ø—Ä–∞—Ü—é–≤–∞—Ç–∏</button>
    <button class="btn btn-danger" @onclick="() => ClearAll(true)" >–û—á–∏—Å—Ç–∏—Ç–∏</button>
    @if (archiveReady)
    {
    <a href="api/archive/@uploadId" class="btn btn-primary" target="_blank">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a>
    }
</div>

<div>
    <p>
        <em>–°—Ç–∞–Ω:</em> <strong>@ButtonClickMessage</strong>
    </p>
</div>

<br />

<!-- –ü—Ä–æ–≥—Ä–µ—Å –±–∞—Ä -->
@if (ShowProgress)
{
<div style="margin-top: 1rem;">
    <label>–ü—Ä–æ–≥—Ä–µ—Å: @Progress%</label>
    <div class="progress">
        <div class="progress-bar" role="progressbar" style="width: @($"{Progress}%");" aria-valuenow="@Progress" aria-valuemin="0" aria-valuemax="100"></div>
    </div>
</div>
}

@if (processing)
{
    <p>–û–±—Ä–æ–±–∫–∞ –∞—Ä—Ö—ñ–≤—É... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.</p>
}
else if (archiveReady)
{
    //<a href="api/archive/@uploadId" download>–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a> 
    <a href="api/archive/@uploadId" target="_blank">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a>
}
else if (timeoutReached)
{
    <p>–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤–∏—á–µ—Ä–ø–∞–Ω–æ.</p>
    <button @onclick="() => RefreshStatus(uploadId)">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
}
else if (hasError)
{
    <p>–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –æ–±—Ä–æ–±–∫–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.</p>
}

<!-- –í–∏–¥—ñ–ª–µ–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è -->
@if (!string.IsNullOrEmpty(SelectedImage) && SelectedFileInfo!= null)
{
<div class="row align-items-start mt-4">
    <!-- –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è -->
    <div class="col-md-4 position-relative">
        <button type="button" class="btn-close" aria-label="Close" @onclick="CancelSelection"></button>

        <img src="@SelectedImage" class="img-thumbnail"/>

    </div>

    <!-- –¢–µ–∫—Å—Ç–æ–≤–µ –ø–æ–ª–µ -->
    <div class="col-md-8">

        <div class="mt-3">

            <EditForm Model="@SelectedFileInfo" OnValidSubmit="ApplyMetadata" class="p-4 border rounded shadow-sm bg-light">
                <div class="form-group mb-3">
                    <label for="headline" class="form-label">–û–ø–∏—Å –¥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è (–∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª—É)</label>
                    <InputText id="headline" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Prompt" placeholder="–û–ø–∏—à—ñ—Ç—å –∫–æ—Ä–æ—Ç–∫–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–æ–∑—É–º—ñ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É" />
                </div>

                <div class="form-group mb-3">
                    <label for="headline" class="form-label">–ó–∞–≥–æ–ª–æ–≤–æ–∫</label>
                    <InputText id="headline" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Headline" placeholder="–í–≤–µ–¥—ñ—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫"/>
                </div>

                <div class="form-group mb-3">
                    <label for="caption" class="form-label">–û–ø–∏—Å</label>
                    <InputTextArea id="caption" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Caption" placeholder="–í–≤–µ–¥—ñ—Ç—å –æ–ø–∏—Å" rows="4"/>
                </div>

                <div class="form-group mb-4">
                    <label for="keywords" class="form-label">–ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞</label>
                    <InputTextArea id="keywords" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Keywords" placeholder="–í–≤–µ–¥—ñ—Ç—å –∫–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∫–æ–º—É" rows="3"/>
                </div>

                <button type="submit" class="btn btn-primary">üíæ –ó–∞–ø–∏—Å–∞—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ</button>

                @if (downloadUrl != null)
                {
                <div class="mt-3">
                    <a href="@downloadUrl" class="btn btn-success" download="updated-image.jpg">‚¨áÔ∏è –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏</a>
                </div>
                }
            </EditForm>



            <div>
                <p><strong>Title: </strong> @SelectedFileInfo.MetadataForStock.Headline</p>
                <p><strong>Category: </strong> @SelectedFileInfo.MetadataForStock.CategoryName</p>
                <p><strong>Description: </strong> @SelectedFileInfo.MetadataForStock.Caption</p>
                <p><strong>Keywords: </strong> @SelectedFileInfo.MetadataForStock.Keywords</p>
            </div>
        </div>

    </div>
</div>
}

<!-- –ü—Ä–µ–≤'—é -->
@if (PagedPreviews.Any())
{
<h5>–ü—Ä–µ–≤‚Äô—é –∑–æ–±—Ä–∞–∂–µ–Ω—å (—Å—Ç–æ—Ä—ñ–Ω–∫–∞ @CurrentPage):</h5>
<div class="thumbnail-grid">
    @foreach (var img in PagedPreviews)
    {
    <div class="col">
        <img src="@img" @key="img" class="preview-img"@onclick="async () => await SelectImageAsync(img)" />
    </div>
    }
</div>

<!-- –ü–∞–≥—ñ–Ω–∞—Ü—ñ—è -->
<div class="d-flex justify-content-between mt-3">
    <button class="btn btn-secondary" @onclick="PrevPage" disabled="@(!CanGoPrev)">‚Üê –ù–∞–∑–∞–¥</button>
    <button class="btn btn-secondary" @onclick="NextPage" disabled="@(!CanGoNext)">–í–ø–µ—Ä–µ–¥ ‚Üí</button>
</div>
}

@code {
    [Inject] private IBackgroundProcessingQueue Queue { get; set; }
    private bool isUploading = false;
    private bool processing = false;
    private bool archiveReady = false;
    private int progress = 0;
    private Guid uploadId;
    private bool timeoutReached = false;
    private bool hasError = false;
    private readonly IBackgroundProcessingQueue _queue = new BackgroundProcessingQueue();
    
    private List<FullFileInfo> ListOfFiles = new();
    private FullFileInfo SelectedFileInfo;
    
    private IEnumerable<string> PagedPreviews =>
        MultipleImagePreviews.Skip((CurrentPage - 1) * PageSize).Take(PageSize);

    private bool CanGoNext => (CurrentPage * PageSize) < MultipleImagePreviews.Count;
    private bool CanGoPrev => CurrentPage > 1;
    
    private Guid FileInputKey = Guid.NewGuid(); // —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–ª—é—á –¥–ª—è –æ—á–∏—â–µ–Ω–Ω—è InputFile
    private List<IBrowserFile> SelectedFiles = new();
    private List<string> MultipleImagePreviews = new();
    private string fileInputKey = Guid.NewGuid().ToString();  // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ–≥–æ –∫–ª—é—á–∞ –¥–ª—è InputFile
    private int PageSize = 100;
    private int CurrentPage = 1;
    private int Progress = 0;
    private bool ShowProgress = false;
    private string? SelectedImage = null;
    private string ButtonClickMessage = "–û—á—ñ–∫—É—î—Ç—å—Å—è –≤–∏–±—ñ—Ä —Ñ–∞–π–ª—ñ–≤...";
    private string? MetadataFromSelectedFile = null;
    private bool ShowPromptingSection = false;
    private IBrowserFile? selectedFile;
    private string? downloadUrl;

    private async Task RefreshStatus(Guid id)
    {
        processing = true;
        timeoutReached = false;
        hasError = false;
        await WaitForArchiveReady(id);
    }
    
    private async Task WaitForArchiveReady(Guid id)
    {
        Console.WriteLine("üîµ WaitForArchiveReady —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");
        
        int maxAttempts = 60;  // –º–∞–∫—Å–∏–º—É–º 60 —Å–ø—Ä–æ–±
        int attempt = 0;
        int delayMs = 1000;    // –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª 1 —Å–µ–∫—É–Ω–¥–∞

        processing = true;
        archiveReady = false;
        timeoutReached = false;
        hasError = false;

        while (attempt < maxAttempts)
        {
            try
            {
                var client = ClientFactory.CreateClient("serverAPI");
                var status = await client.GetStringAsync($"api/archive/status/{id}");

                if (status == "done")
                {
                    processing = false;
                    archiveReady = true;
                    ButtonClickMessage = "–ê—Ä—Ö—ñ–≤ –≥–æ—Ç–æ–≤–∏–π –¥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è";
                    StateHasChanged();
                    return;
                }
                else if (status == "error")
                {
                    processing = false;
                    hasError = true;
                    StateHasChanged();
                    return;
                }
            }
            catch
            {
                // –Ø–∫—â–æ –ø–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É - —Ç–µ–∂ –ø–æ–∑–Ω–∞—á–∏–º–æ –ø–æ–º–∏–ª–∫—É (–∞–±–æ –º–æ–∂–Ω–∞ –ø–æ–≤—Ç–æ—Ä–∏—Ç–∏)
                processing = false;
                hasError = true;
                StateHasChanged();
                return;
            }

            attempt++;

            // –ü–æ—Å—Ç—É–ø–æ–≤–æ –∑–±—ñ–ª—å—à—É—î–º–æ —ñ–Ω—Ç–µ—Ä–≤–∞–ª, —â–æ–± –∑–º–µ–Ω—à–∏—Ç–∏ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
            await Task.Delay(delayMs);
            delayMs = Math.Min(delayMs + 500, 5000); // –º–∞–∫—Å–∏–º—É–º 5 —Å–µ–∫—É–Ω–¥ –º—ñ–∂ –∑–∞–ø–∏—Ç–∞–º–∏

            StateHasChanged(); // –æ–Ω–æ–≤–∏—Ç–∏ UI, —â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–±–æ —Ç–∞–π–º–µ—Ä
        }

        // –Ø–∫—â–æ –¥—ñ–π—à–ª–∏ —Å—é–¥–∏ ‚Äî —á–∞—Å –≤–∏—á–µ—Ä–ø–∞–Ω–æ
        processing = false;
        timeoutReached = true;
        StateHasChanged();
    }

    private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
    { 
        ButtonClickMessage = "–û–±—Ä–æ–±–ª—è—é—Ç—å—Å—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è";
        StateHasChanged();
        
        Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");
      List<IBrowserFile> files;
      try
      {
          files = e.GetMultipleFiles(1000).ToList();
      }
      catch (Exception ex)
      {
          hasError = true;
          Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
          isUploading = false;
          StateHasChanged();
          return;
      }

      // –û–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
      long totalSize = files.Sum(f => f.Size);
      const long maxTotalSize = 2L * 1024 * 1024 * 1024; //2GB
      if (totalSize > maxTotalSize)
      {
          hasError = true;
          isUploading = false;
          Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 1 GB");
          StateHasChanged();
          return;
      }

      var client = ClientFactory.CreateClient("serverAPI");

      try
      {
          int currentFile = 0;


              using var content = new MultipartFormDataContent();
              
              ShowProgress = true;
              Progress = 0;

              int processedFiles = 0;

              foreach (var file in files)
              {
                  using var stream = file.OpenReadStream(1024 * 1024 * 50);
                  using var ms = new MemoryStream();
                  await stream.CopyToAsync(ms);
                  var fileBytes = ms.ToArray();

                  var byteContent = new ByteArrayContent(fileBytes);
                  byteContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);

                  content.Add(byteContent, "files", file.Name);
                  
                  var base64 = Convert.ToBase64String(ms.ToArray());
                  MultipleImagePreviews.Add($"data:{file.ContentType};base64,{base64}");
                    
                  // –î–æ–¥–∞—î–º–æ —Ñ–∞–π–ª —ñ –π–æ–≥–æ Base64 –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è
                  FullFileInfo _FileInfo = new();

                  _FileInfo.File = file;
                  _FileInfo.Base64 = base64;
                  _FileInfo.Name = file.Name;
                  _FileInfo.MetadataForStock.Prompt = await _FileInfo.MetadataForStock.GetPromptFromMetadata(_FileInfo);
                    
                  ListOfFiles.Add(_FileInfo);
                  
                  processedFiles++;
                  Progress = (int)((double)processedFiles / files.Count * 100);
                  StateHasChanged(); // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—è UI –ø—ñ—Å–ª—è –∫–æ–∂–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏
              }

              ShowProgress = false;

              var response = await client.PostAsync("api/archive/uploadfiles", content);

              if (!response.IsSuccessStatusCode)
              {
                  Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –∑–æ–±—Ä–∞–∂–µ–Ω—å –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {response.StatusCode}");
                  hasError = true;
                  return;
              }

              var raw = await response.Content.ReadAsStringAsync();
              if (!Guid.TryParse(raw.Trim('"'), out uploadId))
              {
                  Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
                  hasError = true;
                  return;
              }
              
              ButtonClickMessage = "–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä";
              Console.WriteLine($"‚úÖ –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä. UploadId: {uploadId}");
              StateHasChanged();
      }
      catch (Exception ex)
      {
          hasError = true;
          Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
      }
      finally
      {
          isUploading = false;
          StateHasChanged();
      }
    }
    
    private void CancelSelection()
    {
        // –°–∫–∏–¥–∞—î –≤–∏–±—ñ—Ä –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        SelectedImage = null;
    }

    private void NextPage()
    {
        if (CanGoNext) CurrentPage++;
    }

    private void PrevPage()
    {
        if (CanGoPrev) CurrentPage--;
    }
    
    public class SomeObj
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

    private void ClearAll(bool withrender)
    {
        try
        {
            SelectedFiles.Clear();
            ListOfFiles.Clear();
            MultipleImagePreviews.Clear();

            if (withrender)
            {
                FileInputKey = Guid.NewGuid(); // –ø—Ä–∏–º—É—à—É—î Blazor –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä–∏—Ç–∏ InputFile  
            }
            
            CurrentPage = 1;
            Progress = 0;
            SelectedImage = null;
            SelectedFileInfo = null;
            ShowProgress = false;
            ShowPromptingSection = false;
            
            ButtonClickMessage = "–°–∫–∏–Ω—É—Ç–æ. –í–∏ –º–æ–∂–µ—Ç–µ –≤–∏–±—Ä–∞—Ç–∏ –Ω–æ–≤—ñ —Ñ–∞–π–ª–∏.";
            
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
 
    }
    
    private async Task SelectImageAsync(string image)
    {
        SelectedImage = image;
        
        
        var base64Data = SelectedImage.Substring(SelectedImage.IndexOf(",") + 1);
        SelectedFileInfo = ListOfFiles.Find(m => m.Base64 == base64Data);

        if (SelectedFileInfo!= null)
        {
            if (string.IsNullOrEmpty(SelectedFileInfo.MetadataForStock.Prompt))
            {
                SelectedFileInfo.MetadataForStock.Prompt = await SelectedFileInfo.MetadataForStock.GetPromptFromMetadata(SelectedFileInfo);
            }
        }
    }

    /*private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
  {
      Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

      isUploading = true;
      processing = false;
      archiveReady = false;
      progress = 0;
      hasError = false;
      StateHasChanged();


      List<IBrowserFile> files;
      try
      {
          files = e.GetMultipleFiles(1000).ToList();
      }
      catch (Exception ex)
      {
          hasError = true;
          Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
          isUploading = false;
          StateHasChanged();
          return;
      }

      // –û–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
      long totalSize = files.Sum(f => f.Size);
      const long maxTotalSize = 2L * 1024 * 1024 * 1024; //2GB
      if (totalSize > maxTotalSize)
      {
          hasError = true;
          isUploading = false;
          Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 1 GB");
          StateHasChanged();
          return;
      }

      var client = ClientFactory.CreateClient("serverAPI");

      try
      {
         // var batches = files.Chunk(10).ToList();
          int currentFile = 0;


              using var content = new MultipartFormDataContent();

              foreach (var file in files)
              {
                  using var stream = file.OpenReadStream(1024 * 1024 * 50);
                  using var ms = new MemoryStream();
                  await stream.CopyToAsync(ms);
                  var fileBytes = ms.ToArray();

                  var byteContent = new ByteArrayContent(fileBytes);
                  byteContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);

                  content.Add(byteContent, "files", file.Name);

                  StateHasChanged();
              }

              var response = await client.PostAsync("api/archive/upload", content);

              if (!response.IsSuccessStatusCode)
              {
                  Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É: {response.StatusCode}");
                  hasError = true;
                  return;
              }

              var raw = await response.Content.ReadAsStringAsync();
              if (!Guid.TryParse(raw.Trim('"'), out uploadId))
              {
                  Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
                  hasError = true;
                  return;
              }

              progress = (int)((double)currentFile / files.Count * 100);

              Console.WriteLine($"‚úÖ –ë–∞—Ç—á –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. UploadId: {uploadId}");
              StateHasChanged();


          processing = true;
          Console.WriteLine("üü¢ –ß–µ–∫–∞—î–º–æ –Ω–∞ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∞—Ä—Ö—ñ–≤—É...");
          await WaitForArchiveReady(uploadId);
      }
      catch (Exception ex)
      {
          hasError = true;
          Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
      }
      finally
      {
          isUploading = false;
          StateHasChanged();
      }
  }*/
private async Task ProcessImages()
{
    if (ListOfFiles.Count > 0)
    {
        ButtonClickMessage = $"–§–∞–π–ª—ñ–≤ –¥–æ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—è: {SelectedFiles.Count}";
        StateHasChanged();
            
        ButtonClickMessage = $"–†–æ–∑–ø–æ—á–∞—Ç–æ –ø—Ä–æ—Ü–µ—Å –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—è...";
        StateHasChanged();

        int processed = 0;

        foreach (FullFileInfo _fullFileInfo in ListOfFiles)
        {
            SelectedFileInfo = _fullFileInfo;

            try
            {
                //SelectedFileInfo.MetadataForStock.Prompt = await SelectedFileInfo.MetadataForStock.GetPromptFromMetadata(SelectedFileInfo);
                await SendPrompt();
                await ApplyMetadata();
            }
            catch (Exception ex)
            {
                Console.WriteLine("–ü–æ–º–∏–ª–∫–∞: " + ex.Message);
                ButtonClickMessage = $"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ {SelectedFileInfo.File.Name}: {ex.Message}";
                StateHasChanged();
                continue; // –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ñ–∞–π–ª—É
            }

            processed++;
            ButtonClickMessage = $"–§–∞–π–ª—ñ–≤ –æ–ø—Ä–∞—Ü—å–æ–≤–∞–Ω–æ : {processed} –∑ {ListOfFiles.Count}";
            StateHasChanged();
        }

        ButtonClickMessage = "–§–æ—Ä–º—É—î—Ç—å—Å—è –∞—Ä—Ö—ñ–≤...";
        StateHasChanged();

        await Task.Yield();
        
        var client = ClientFactory.CreateClient("serverAPI"); 
        
        List<FileInfoSimple> ListOfFilesSimple = ListOfFiles
            .Select(f => new FileInfoSimple
            {
                MetadataForStock = f.MetadataForStock,
                NewBase64 = f.NewBase64,
                Name = f.File.Name
            })
            .ToList();
        
       // var content = new MultipartFormDataContent();
        

        // –î–æ–¥–∞—î–º–æ –º–µ—Ç–∞–¥–∞–Ω—ñ —É —Ñ–æ—Ä–º–∞—Ç—ñ JSON
       // var metadataJson = JsonSerializer.Serialize(ListOfFilesSimple);
       // content.Add(new StringContent(metadataJson, Encoding.UTF8, "application/json"), "metadata");

        // –ù–∞–¥—Å–∏–ª–∞—î–º–æ –∑–∞–ø–∏—Ç
        
        var json = JsonSerializer.Serialize(ListOfFilesSimple);
        Console.WriteLine(json);
        var responseCSV    = await client.PostAsJsonAsync($"api/archive/createcsv/{uploadId}", ListOfFilesSimple);
        
        var response = await client.GetStringAsync($"api/archive/uploadzip/{uploadId}");

        if (response.ToString() != "OK")
        {
            Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É");
            hasError = true;
            return;
        }
        else
        {
            Console.WriteLine($" –ó–∞–ø—É—â–µ–Ω–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É");
            await WaitForArchiveReady(uploadId);   
        }
    }
}

private async Task ApplyMetadata()
{
    if (SelectedFileInfo == null)
        return;
    
    //using var content = new MultipartFormDataContent();
    
    var client = ClientFactory.CreateClient("serverAPI");  
    List<FileInfoSimple> ListOfFilesSimple = ListOfFiles
        .Select(f => new FileInfoSimple
        {
            MetadataForStock = f.MetadataForStock,
            NewBase64 = f.NewBase64,
            Name = f.File.Name
        })
        .ToList();

    var response = await client.PostAsJsonAsync($"api/archive/setmetadata/{uploadId}", ListOfFilesSimple);
}

  private string Prompt { get; set; } = @"Act as a professional stock content expert with deep knowledge of visual trends, keyword optimization, and commercial relevance. Your task is to analyze the uploaded image and generate a structured stock-ready output in valid JSON format, using the most accurate and up-to-date stock terminology.

Ensure the content is highly relevant, commercially usable, and optimized for searchability. Use trendy, specific, and high-ranking keywords commonly used on platforms like Shutterstock, Adobe Stock, iStock, etc. Avoid generic or outdated terms.

Your response must include the following fields:

""title"" ‚Äì A short, descriptive, and engaging title (maximum 10 words).

""categoryName"" ‚Äì The most accurate image category based on standard stock taxonomy.
 (1. Animals: Content related to animals, insects, or pets ‚Äî at home or in the wild. 
2. Buildings and Architecture: Structures like homes, interiors, offices, temples, barns, factories, and shelters. 
3. Business: People in business settings, offices, business concepts, finance, and money
4. Drinks: Content related to beer, wine, spirits, and other drinks. 
5. The Environment: Depictions of nature or the places we work and live. 
6. States of Mind: Content related to people‚Äôs emotions and inner voices. 
7. Food: Anything focused on food and eating. 
8. Graphic Resources: Backgrounds, textures, and symbols. 
9. Hobbies and Leisure: Pastime activities that bring joy and/or relaxation, such as knitting, building model airplanes, and sailing. 
10. Industry: Depictions of work and manufacturing, like building cars, forging steel, producing clothing, or producing energy. 
11. Landscape: Vistas, cities, nature, and other locations. 
12. Lifestyle: The environments and activities of people at home, work, and play. 
13. People: People of all ages, ethnicities, cultures, genders, and abilities. 
14. Plants and Flowers: Close-ups of the natural world. 
15. Culture and Religion: Depictions of the traditions, beliefs, and cultures of people around the world. 
16. Science: Content with a focus on the applied, natural, medical, and theoretical sciences. 
17. Social Issues: Poverty, inequality, politics, violence, and other depictions of social issues. 
18. Sports: Content focused on sports and fitness, including football, basketball, hunting, yoga, and skiing. 
19. Technology: Computers, smartphones, virtual reality, and other tools designed to increase productivity. 
20. Transport: Different types of transportation, including cars, buses, trains, planes, and highway systems. 
21. Travel: Local and worldwide travel, culture, and lifestyles.)

""category"" ‚Äì number related to ""categoryName"" 

""description"" ‚Äì A clear, medium-length description (2‚Äì3 sentences) that highlights the visual content, composition, colors, emotions, and possible commercial applications (maximum 150 characters, it is strong rule!).

""keywords"" ‚Äì CSV formatted string with default separator (a comma) :exactly 30 highly relevant, trend-aware, and stock-optimized keywords, including popular search terms like ""isolated"", ""copy space"", ""cut out"", ""flat lay"", ""top view"", ""minimalist"", ""authentic"", ""trendy"", ""vibrant colors"", ""clean design"", etc., depending on the image content.";

    private string Response { get; set; } = string.Empty;
    private bool IsLoading { get; set; } = false;


    private async Task SendPrompt()
    {
        if (string.IsNullOrWhiteSpace(Prompt)) return;

        IsLoading = true;
        Response = "";

        try
        {
            string _promtforgemmini = Prompt;

            if (!string.IsNullOrEmpty(SelectedFileInfo.MetadataForStock.Prompt))
            {
                _promtforgemmini = _promtforgemmini +  "\n\n For better context, here is the prompt used to generate the image:" + SelectedFileInfo.MetadataForStock.Prompt;
            }
            var resultDict = await Gemini.GetImageInfo(SelectedFileInfo, _promtforgemmini);
            await Task.Delay(1000);
            
            SelectedFileInfo.MetadataForStock.Headline = resultDict.GetValueOrDefault("title").ToString();
            SelectedFileInfo.MetadataForStock.Keywords = resultDict.GetValueOrDefault("keywords").ToString();
            SelectedFileInfo.MetadataForStock.Caption = resultDict.GetValueOrDefault("description").ToString();
            SelectedFileInfo.MetadataForStock.Category = Int32.Parse(resultDict.GetValueOrDefault("category").ToString());
            SelectedFileInfo.MetadataForStock.CategoryName = resultDict.GetValueOrDefault("categoryName").ToString();
            
            //   string json = await Gemini.GetAnswer(filePath, apiKey, Prompt);
            //resultDict = await Gemini.GetAnswerD(filePath, apiKey, Prompt);

            // Response = json;
        }
        catch (Exception ex)
        {
            Response = $"‚ùå –ü–æ–º–∏–ª–∫–∞: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
        }
    }

/*private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
{
    Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

    isUploading = true;
    processing = false;
    archiveReady = false;
    progress = 0;
    hasError = false;
    StateHasChanged();

    
    List<IBrowserFile> files;
    try
    {
        files = e.GetMultipleFiles(1000).ToList();
    }
    catch (Exception ex)
    {
        hasError = true;
        Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
        isUploading = false;
        StateHasChanged();
        return;
    }

    // –û–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
    long totalSize = files.Sum(f => f.Size);
    const long maxTotalSize = 2L * 1024 * 1024 * 1024; //2GB
    if (totalSize > maxTotalSize)
    {
        hasError = true;
        isUploading = false;
        Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 1 GB");
        StateHasChanged();
        return;
    }

    var client = ClientFactory.CreateClient("serverAPI");

    try
    {
        var batches = files.Chunk(10).ToList();
        int currentFile = 0;

        foreach (var batch in batches)
        {
            Console.WriteLine("üîµ HandleSelectedFiles –æ–±—Ä–æ–±–ª—é—î –±–∞—Ç—á");
            
            using var content = new MultipartFormDataContent();

            foreach (var file in batch)
            {
                await using var stream = file.OpenReadStream(1024 * 1024 * 50); // –¥–æ 50MB
                var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                memoryStream.Position = 0;

                var streamContent = new StreamContent(memoryStream);
                streamContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
                content.Add(streamContent, "files", file.Name);
            }

            Console.WriteLine("‚û°Ô∏è –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –±–∞—Ç—á—É...");
            var response = await client.PostAsync("api/archive/upload", content);

            if (!response.IsSuccessStatusCode)
            {
                Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É: {response.StatusCode}");
                hasError = true;
                return;
            }

            var raw = await response.Content.ReadAsStringAsync();
            if (!Guid.TryParse(raw.Trim('"'), out uploadId))
            {
                Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
                hasError = true;
                return;
            }

            currentFile += batch.Count();
            progress = (int)((double)currentFile / files.Count * 100);

            Console.WriteLine($"‚úÖ –ë–∞—Ç—á –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. UploadId: {uploadId}, –ü—Ä–æ–≥—Ä–µ—Å: {progress}%");
            StateHasChanged();
        }

        processing = true;
        Console.WriteLine("üü¢ –ß–µ–∫–∞—î–º–æ –Ω–∞ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∞—Ä—Ö—ñ–≤—É...");
        await WaitForArchiveReady(uploadId);
    }
    catch (Exception ex)
    {
        hasError = true;
        Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
    }
    finally
    {
        isUploading = false;
        StateHasChanged();
    }
}*/




    
}

<style>
    .preview-img {
        width: 100%;
        max-height: 150px;
        max-width: 150px;
        object-fit: cover;
        border: 2px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        cursor: pointer;
    }
    .thumbnail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 10px;
        margin-top: 1rem;
    }
</style>