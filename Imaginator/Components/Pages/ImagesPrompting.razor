@page "/images-prompting"
@rendermode InteractiveServer

@using System.Collections.Generic
@using System.Diagnostics
@using System.Net.Http.Headers
@using System.Text
@using System.Text.Json

@inject IWebHostEnvironment env

<h3>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å</h3>

<!-- –í–∏–±—ñ—Ä —Ñ–∞–π–ª—ñ–≤ -->
<div class="mb-3">
    <label for="fileInput" class="form-label">–û–±–µ—Ä—ñ—Ç—å —Ñ–∞–π–ª–∏ –∞–±–æ —Ç–µ–∫—É:</label>
    <InputFile id="fileInput" multiple class="form-control" OnChange="HandleSelectedFiles" @key="FileInputKey"/>
</div>

<!-- –ö–Ω–æ–ø–∫–∏ -->
<div>
    <button class="btn btn-primary" @onclick="ProcessImages">–û–ø—Ä–∞—Ü—é–≤–∞—Ç–∏</button>
    <button class="btn btn-danger" @onclick="() => ClearAll(true)">–û—á–∏—Å—Ç–∏—Ç–∏</button>
    @if (archiveReady)
    {
        <a href="api/archive/@uploadId" class="btn btn-primary" target="_blank">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a>
    }
</div>

<div>
    <p>
        <em>–°—Ç–∞–Ω:</em> <strong>@ButtonClickMessage</strong>
    </p>
</div>

<br/>

<!-- –ü—Ä–æ–≥—Ä–µ—Å –±–∞—Ä -->
@if (ShowProgress)
{
    <div style="margin-top: 1rem;">
        <label>–ü—Ä–æ–≥—Ä–µ—Å: @Progress%</label>
        <div class="progress">
            <div class="progress-bar" role="progressbar" style="width: @($"{Progress}%");" aria-valuenow="@Progress" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
    </div>
}

@if (processing)
{
    <p>–û–±—Ä–æ–±–∫–∞ –∞—Ä—Ö—ñ–≤—É... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.</p>
}
else if (archiveReady)
{
//<a href="api/archive/@uploadId" download>–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a> 
    <a href="api/archive/@uploadId" target="_blank">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∞—Ä—Ö—ñ–≤</a>
}
else if (timeoutReached)
{
    <p>–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤–∏—á–µ—Ä–ø–∞–Ω–æ.</p>
    <button @onclick="() => RefreshStatus(uploadId)">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
}
else if (hasError)
{
    <p>–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –æ–±—Ä–æ–±–∫–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.</p>
}

<!-- –í–∏–¥—ñ–ª–µ–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è -->
@if (!string.IsNullOrEmpty(SelectedImage) && SelectedFileInfo != null)
{
    <div class="row align-items-start mt-4">
        <!-- –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è -->
        <div class="col-md-4 position-relative">
            <button type="button" class="btn-close" aria-label="Close" @onclick="CancelSelection"></button>

            <img src="@SelectedImage" class="img-thumbnail"/>

        </div>

        <!-- –¢–µ–∫—Å—Ç–æ–≤–µ –ø–æ–ª–µ -->
        <div class="col-md-8">

            <div class="mt-3">

                <EditForm Model="@SelectedFileInfo" OnValidSubmit="ApplyMetadata" class="p-4 border rounded shadow-sm bg-light">
                    <div class="form-group mb-3">
                        <label for="headline" class="form-label">–û–ø–∏—Å –¥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è (–∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª—É)</label>
                        <InputTextArea id="headline" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Prompt" placeholder="–û–ø–∏—à—ñ—Ç—å –∫–æ—Ä–æ—Ç–∫–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Ä–æ–∑—É–º—ñ–Ω–Ω—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É" rows="4"/>
                    </div>

                    <div class="form-group mb-3">
                        <label for="headline" class="form-label">–ó–∞–≥–æ–ª–æ–≤–æ–∫</label>
                        <InputText id="headline" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Headline" placeholder="–í–≤–µ–¥—ñ—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫"/>
                    </div>

                    <div class="form-group mb-3">
                        <label for="caption" class="form-label">–û–ø–∏—Å</label>
                        <InputTextArea id="caption" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Caption" placeholder="–í–≤–µ–¥—ñ—Ç—å –æ–ø–∏—Å" rows="4"/>
                    </div>

                    <div class="form-group mb-4">
                        <label for="keywords" class="form-label">–ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞</label>
                        <InputTextArea id="keywords" class="form-control" @bind-Value="SelectedFileInfo.MetadataForStock.Keywords" placeholder="–í–≤–µ–¥—ñ—Ç—å –∫–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∫–æ–º—É" rows="3"/>
                    </div>

                    <button type="submit" class="btn btn-primary">üíæ –ó–∞–ø–∏—Å–∞—Ç–∏ –º–µ—Ç–∞–¥–∞–Ω—ñ</button>

                    @if (downloadUrl != null)
                    {
                        <div class="mt-3">
                            <a href="@downloadUrl" class="btn btn-success" download="updated-image.jpg">‚¨áÔ∏è –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ –º–µ—Ç–∞–¥–∞–Ω–∏–º–∏</a>
                        </div>
                    }
                </EditForm>


                <div>
                    <p>
                        <strong>Title: </strong> @SelectedFileInfo.MetadataForStock.Headline
                    </p>
                    <p>
                        <strong>Category: </strong> @SelectedFileInfo.MetadataForStock.CategoryName
                    </p>
                    <p>
                        <strong>Description: </strong> @SelectedFileInfo.MetadataForStock.Caption
                    </p>
                    <p>
                        <strong>Keywords: </strong> @SelectedFileInfo.MetadataForStock.Keywords
                    </p>
                </div>
            </div>

        </div>
    </div>
}

<!-- –ü—Ä–µ–≤'—é -->
@if (PagedPreviews.Any())
{
    <h5>–ü—Ä–µ–≤‚Äô—é –∑–æ–±—Ä–∞–∂–µ–Ω—å (—Å—Ç–æ—Ä—ñ–Ω–∫–∞ @CurrentPage):</h5>
    <div class="thumbnail-grid">
        @foreach (var img in PagedPreviews)
        {
            <div class="col">
                <img src="@img" @key="img" class="preview-img"@onclick="async () => await SelectImageAsync(img)"/>
            </div>
        }
    </div>

    <!-- –ü–∞–≥—ñ–Ω–∞—Ü—ñ—è -->
    <div class="d-flex justify-content-between mt-3">
        <button class="btn btn-secondary" @onclick="PrevPage" disabled="@(!CanGoPrev)">‚Üê –ù–∞–∑–∞–¥</button>
        <button class="btn btn-secondary" @onclick="NextPage" disabled="@(!CanGoNext)">–í–ø–µ—Ä–µ–¥ ‚Üí</button>
    </div>
}

@code {
    [Inject] private IBackgroundProcessingQueue Queue { get; set; }
    private bool isUploading = false;
    private bool processing = false;
    private bool archiveReady = false;
    private int progress = 0;
    private Guid uploadId;
    private bool timeoutReached = false;
    private bool hasError = false;
    private readonly IBackgroundProcessingQueue _queue = new BackgroundProcessingQueue();

    private List<FullFileInfo> ListOfFiles = new();
    private FullFileInfo SelectedFileInfo;

    private IEnumerable<string> PagedPreviews =>
        MultipleImagePreviews.Skip((CurrentPage - 1) * PageSize).Take(PageSize);

    private bool CanGoNext => (CurrentPage * PageSize) < MultipleImagePreviews.Count;
    private bool CanGoPrev => CurrentPage > 1;

    private Guid FileInputKey = Guid.NewGuid(); // —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π –∫–ª—é—á –¥–ª—è –æ—á–∏—â–µ–Ω–Ω—è InputFile
    private List<IBrowserFile> SelectedFiles = new();
    private List<string> MultipleImagePreviews = new();
    private string fileInputKey = Guid.NewGuid().ToString(); // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —É–Ω—ñ–∫–∞–ª—å–Ω–æ–≥–æ –∫–ª—é—á–∞ –¥–ª—è InputFile
    private int PageSize = 50;
    private int CurrentPage = 1;
    private int Progress = 0;
    private bool ShowProgress = false;
    private string? SelectedImage = null;
    private string ButtonClickMessage = "–û—á—ñ–∫—É—î—Ç—å—Å—è –≤–∏–±—ñ—Ä —Ñ–∞–π–ª—ñ–≤...";
    private string? MetadataFromSelectedFile = null;
    private bool ShowPromptingSection = false;
    private IBrowserFile? selectedFile;
    private string? downloadUrl;

    [Inject] public IHttpClientFactory ClientFactory { get; set; }

    private HttpClient httpClient;

    protected override void OnInitialized()
    {
        httpClient = ClientFactory.CreateClient("serverAPI");
    }

    private async Task RefreshStatus(Guid id)
    {
        processing = true;
        timeoutReached = false;
        hasError = false;
        await WaitForArchiveReady(id);
    }

    private async Task WaitForArchiveReady(Guid id)
    {
        Console.WriteLine("üîµ WaitForArchiveReady —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

        int maxAttempts = 60; // –º–∞–∫—Å–∏–º—É–º 60 —Å–ø—Ä–æ–±
        int attempt = 0;
        int delayMs = 1000; // –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª 1 —Å–µ–∫—É–Ω–¥–∞

        processing = true;
        archiveReady = false;
        timeoutReached = false;
        hasError = false;

        while (attempt < maxAttempts)
        {
            try
            {
                var status = await httpClient.GetStringAsync($"api/archive/status/{id}");

                if (status == "done")
                {
                    processing = false;
                    archiveReady = true;
                    ButtonClickMessage = "–ê—Ä—Ö—ñ–≤ –≥–æ—Ç–æ–≤–∏–π –¥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è";
                    StateHasChanged();
                    return;
                }
                else if (status == "error")
                {
                    processing = false;
                    hasError = true;
                    StateHasChanged();
                    return;
                }
            }
            catch
            {
// –Ø–∫—â–æ –ø–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Ç—É - —Ç–µ–∂ –ø–æ–∑–Ω–∞—á–∏–º–æ –ø–æ–º–∏–ª–∫—É (–∞–±–æ –º–æ–∂–Ω–∞ –ø–æ–≤—Ç–æ—Ä–∏—Ç–∏)
                processing = false;
                hasError = true;
                StateHasChanged();
                return;
            }

            attempt++;

// –ü–æ—Å—Ç—É–ø–æ–≤–æ –∑–±—ñ–ª—å—à—É—î–º–æ —ñ–Ω—Ç–µ—Ä–≤–∞–ª, —â–æ–± –∑–º–µ–Ω—à–∏—Ç–∏ –Ω–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
            await Task.Delay(delayMs);
            delayMs = Math.Min(delayMs + 500, 5000); // –º–∞–∫—Å–∏–º—É–º 5 —Å–µ–∫—É–Ω–¥ –º—ñ–∂ –∑–∞–ø–∏—Ç–∞–º–∏

            StateHasChanged(); // –æ–Ω–æ–≤–∏—Ç–∏ UI, —â–æ–± –ø–æ–∫–∞–∑–∞—Ç–∏ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–±–æ —Ç–∞–π–º–µ—Ä
        }

// –Ø–∫—â–æ –¥—ñ–π—à–ª–∏ —Å—é–¥–∏ ‚Äî —á–∞—Å –≤–∏—á–µ—Ä–ø–∞–Ω–æ
        processing = false;
        timeoutReached = true;
        StateHasChanged();
    }

    private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
    {
        var swTotal = Stopwatch.StartNew();
        ButtonClickMessage = "–û–±—Ä–æ–±–ª—è—é—Ç—å—Å—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è";
        StateHasChanged();
        Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

        var sw = Stopwatch.StartNew();

        List<IBrowserFile> files;
        try
        {
            files = e.GetMultipleFiles(1000).ToList();
        }
        catch (Exception ex)
        {
            hasError = true;
            Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
            isUploading = false;
            StateHasChanged();
            return;
        }

        sw.Stop();
        Console.WriteLine($"‚è± –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–ø–∏—Å–∫—É —Ñ–∞–π–ª—ñ–≤: {sw.ElapsedMilliseconds} ms");

// –†–æ–∑–º—ñ—Ä
        sw.Restart();
        long totalSize = files.Sum(f => f.Size);
        const long maxTotalSize = 2L * 1024 * 1024 * 1024;
        if (totalSize > maxTotalSize)
        {
            hasError = true;
            isUploading = false;
            Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 2 GB");
            StateHasChanged();
            return;
        }

        sw.Stop();
        Console.WriteLine($"‚è± –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É: {sw.ElapsedMilliseconds} ms");

        try
        {
            using var content = new MultipartFormDataContent();
            ShowProgress = true;
            Progress = 0;

            int processedFiles = 0;
            int totalFiles = files.Count;

            foreach (var file in files)
            {
                using var stream = file.OpenReadStream(1024 * 1024 * 50);
                using var ms = new MemoryStream();
                await stream.CopyToAsync(ms);
                var fileBytes = ms.ToArray();

                var byteContent = new ByteArrayContent(fileBytes);
                byteContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);

                content.Add(byteContent, "files", file.Name);

// –î–æ–¥–∞—î–º–æ —Ñ–∞–π–ª —ñ –π–æ–≥–æ Base64 –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è
                FullFileInfo _FileInfo = new();

                _FileInfo.File = file;
                _FileInfo.Name = file.Name;
                //_FileInfo.MetadataForStock.Prompt = await _FileInfo.MetadataForStock.GetPromptFromMetadata(_FileInfo);
                SelectedFileInfo = _FileInfo;
                await SendPrompt();

                ListOfFiles.Add(_FileInfo);

                processedFiles++;
                Progress = (int)((double)processedFiles / files.Count * 100);
                StateHasChanged(); // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—è UI –ø—ñ—Å–ª—è –∫–æ–∂–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏
            }

            sw.Restart();
            ShowProgress = false;

            var response = await httpClient.PostAsync("api/archive/uploadfiles", content);
            sw.Stop();
            Console.WriteLine($"‚è± –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {sw.ElapsedMilliseconds} ms");

            sw.Restart();
            var raw = await response.Content.ReadAsStringAsync();
            sw.Stop();
            Console.WriteLine($"‚è± –ß–∏—Ç–∞–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ —Å–µ—Ä–≤–µ—Ä–∞: {sw.ElapsedMilliseconds} ms");

            if (!response.IsSuccessStatusCode)
            {
                Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ: {response.StatusCode}");
                hasError = true;
                return;
            }

            if (!Guid.TryParse(raw.Trim('"'), out uploadId))
            {
                Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
                hasError = true;
                return;
            }

            ButtonClickMessage = "–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è —É—Å–ø—ñ—à–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä";

            MultipleImagePreviews.Clear();
            foreach (var file in ListOfFiles)
            {
// –§–∞–π–ª–∏ –ª–µ–∂–∞—Ç—å —É wwwroot/uploads/{uploadId}/
// –¢–æ–±—Ç–æ URL –±—É–¥–µ /uploads/{uploadId}/{filename}
                var url = $"/uploads/{uploadId}/{file.Name}";
                MultipleImagePreviews.Add(url);
                file.DownloadUrl = Path.Combine(env.WebRootPath, url);
            }

            Console.WriteLine($"‚úÖ UploadId: {uploadId}");
        }
        catch (Exception ex)
        {
            hasError = true;
            Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
            swTotal.Stop();
            Console.WriteLine($"‚è± –ó–∞–≥–∞–ª—å–Ω–∏–π —á–∞—Å –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: {swTotal.ElapsedMilliseconds} ms");
        }
    }


    private void CancelSelection()
    {
// –°–∫–∏–¥–∞—î –≤–∏–±—ñ—Ä –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        SelectedImage = null;
    }

    private void NextPage()
    {
        if (CanGoNext) CurrentPage++;
    }

    private void PrevPage()
    {
        if (CanGoPrev) CurrentPage--;
    }

    public class SomeObj
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

    private void ClearAll(bool withrender)
    {
        try
        {
            SelectedFiles.Clear();
            ListOfFiles.Clear();
            MultipleImagePreviews.Clear();

            if (withrender)
            {
                FileInputKey = Guid.NewGuid(); // –ø—Ä–∏–º—É—à—É—î Blazor –ø–µ—Ä–µ—Ä–µ–Ω–¥–µ—Ä–∏—Ç–∏ InputFile  
            }

            CurrentPage = 1;
            Progress = 0;
            SelectedImage = null;
            SelectedFileInfo = null;
            ShowProgress = false;
            ShowPromptingSection = false;

            ButtonClickMessage = "–°–∫–∏–Ω—É—Ç–æ. –í–∏ –º–æ–∂–µ—Ç–µ –≤–∏–±—Ä–∞—Ç–∏ –Ω–æ–≤—ñ —Ñ–∞–π–ª–∏.";
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
    }

    private async Task SelectImageAsync(string image)
    {
        SelectedImage = image;


        var base64Data = SelectedImage.Substring(SelectedImage.IndexOf(",") + 1);
        SelectedFileInfo = ListOfFiles.Find(m => m.Name == Path.GetFileName(image));

        if (SelectedFileInfo != null)
        {
            if (string.IsNullOrEmpty(SelectedFileInfo.MetadataForStock.Prompt))
            {
                SelectedFileInfo.MetadataForStock.Prompt = await SelectedFileInfo.MetadataForStock.GetPromptFromMetadata(SelectedFileInfo);
            }
        }
    }

/*private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
{
  Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

  isUploading = true;
  processing = false;
  archiveReady = false;
  progress = 0;
  hasError = false;
  StateHasChanged();


  List<IBrowserFile> files;
  try
  {
      files = e.GetMultipleFiles(1000).ToList();
  }
  catch (Exception ex)
  {
      hasError = true;
      Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
      isUploading = false;
      StateHasChanged();
      return;
  }

  // –û–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
  long totalSize = files.Sum(f => f.Size);
  const long maxTotalSize = 2L * 1024 * 1024 * 1024; //2GB
  if (totalSize > maxTotalSize)
  {
      hasError = true;
      isUploading = false;
      Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 1 GB");
      StateHasChanged();
      return;
  }

  var client = ClientFactory.CreateClient("serverAPI");

  try
  {
     // var batches = files.Chunk(10).ToList();
      int currentFile = 0;


          using var content = new MultipartFormDataContent();

          foreach (var file in files)
          {
              using var stream = file.OpenReadStream(1024 * 1024 * 50);
              using var ms = new MemoryStream();
              await stream.CopyToAsync(ms);
              var fileBytes = ms.ToArray();

              var byteContent = new ByteArrayContent(fileBytes);
              byteContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);

              content.Add(byteContent, "files", file.Name);

              StateHasChanged();
          }

          var response = await client.PostAsync("api/archive/upload", content);

          if (!response.IsSuccessStatusCode)
          {
              Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É: {response.StatusCode}");
              hasError = true;
              return;
          }

          var raw = await response.Content.ReadAsStringAsync();
          if (!Guid.TryParse(raw.Trim('"'), out uploadId))
          {
              Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
              hasError = true;
              return;
          }

          progress = (int)((double)currentFile / files.Count * 100);

          Console.WriteLine($"‚úÖ –ë–∞—Ç—á –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. UploadId: {uploadId}");
          StateHasChanged();


      processing = true;
      Console.WriteLine("üü¢ –ß–µ–∫–∞—î–º–æ –Ω–∞ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∞—Ä—Ö—ñ–≤—É...");
      await WaitForArchiveReady(uploadId);
  }
  catch (Exception ex)
  {
      hasError = true;
      Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
  }
  finally
  {
      isUploading = false;
      StateHasChanged();
  }
}*/
    private async Task ProcessImages()
    {
        if (ListOfFiles.Count > 0)
        {
            ButtonClickMessage = $"–§–∞–π–ª—ñ–≤ –¥–æ –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—è: {SelectedFiles.Count}";
            StateHasChanged();

            ButtonClickMessage = $"–†–æ–∑–ø–æ—á–∞—Ç–æ –ø—Ä–æ—Ü–µ—Å –æ–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—è...";
            StateHasChanged();

            int processed = 0;
            var tasks = new List<Task>();
            foreach (FullFileInfo _fullFileInfo in ListOfFiles)
            {
                SelectedFileInfo = _fullFileInfo;

                try
                {
//tasks.Add(SendPrompt());
                    await SendPrompt();
                }
                catch (Exception ex)
                {
                    Console.WriteLine("–ü–æ–º–∏–ª–∫–∞: " + ex.Message);
                    ButtonClickMessage = $"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ {SelectedFileInfo.File.Name}: {ex.Message}";
                    StateHasChanged();
                    continue; // –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ñ–∞–π–ª—É
                }

                processed++;
                ButtonClickMessage = $"–§–∞–π–ª—ñ–≤ –æ–ø—Ä–∞—Ü—å–æ–≤–∞–Ω–æ : {processed} –∑ {ListOfFiles.Count}";
                StateHasChanged();
            }

// await Task.WhenAll(tasks);

            await ApplyMetadata();

            ButtonClickMessage = "–§–æ—Ä–º—É—î—Ç—å—Å—è –∞—Ä—Ö—ñ–≤...";
            StateHasChanged();

            await Task.Yield();

            List<FileInfoSimple> ListOfFilesSimple = ListOfFiles
                .Select(f => new FileInfoSimple
                {
                    MetadataForStock = f.MetadataForStock,
                    NewBase64 = f.NewBase64,
                    Name = f.File.Name
                })
                .ToList();

// –ù–∞–¥—Å–∏–ª–∞—î–º–æ –∑–∞–ø–∏—Ç

            var json = JsonSerializer.Serialize(ListOfFilesSimple);
            Console.WriteLine(json);
            var responseCSV = await httpClient.PostAsJsonAsync($"api/archive/createcsv/{uploadId}", ListOfFilesSimple);

            var response = await httpClient.GetStringAsync($"api/archive/uploadzip/{uploadId}");

            if (response.ToString() != "OK")
            {
                Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É");
                hasError = true;
                return;
            }
            else
            {
                Console.WriteLine($" –ó–∞–ø—É—â–µ–Ω–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É");
                await WaitForArchiveReady(uploadId);
            }
        }
    }

    private async Task ApplyMetadata()
    {
        if (SelectedFileInfo == null)
            return;

        List<FileInfoSimple> ListOfFilesSimple = ListOfFiles
            .Select(f => new FileInfoSimple
            {
                MetadataForStock = f.MetadataForStock,
                NewBase64 = f.NewBase64,
                Name = f.File.Name
            })
            .ToList();

        var response = await httpClient.PostAsJsonAsync($"api/archive/setmetadata/{uploadId}", ListOfFilesSimple);
    }

    private string Prompt { get; set; } = @"
Act as a professional prompt engineer for MidJourney V7 with expertise in reverse-engineering visuals into descriptive prompts.

You will be given an image.

Your task is to:
1. Analyze the image in detail, considering:
   - Detailed subject and scene (who/what is shown, doing what)
   - Art style (photorealistic, illustration and its style, anime, 3D render, oil painting, etc.)
   - Camera angle, composition, lighting (soft, harsh, ambient, cinematic, etc.)
   - Color palette and mood (warm, cold, pastel, vibrant, gloomy, etc.)
   - Textures, materials, background details, and focus depth
2. Write a prompt for MidJourney v7 that recreates this image as precisely as possible.
3. Use structured prompt syntax:
   - Start with the main subject
   - Add adjectives describing the subject very detailed
   - Include environment/setting
   - Specify art style
   - Add lighting & mood descriptors
   - If it is a photo - Add the one of the best camera and light , for example: Shot with Nikon D850, 35mm lens, soft daylight
   - Finish with only two **MidJourney parameters** : ratio (Determine the file's width and height, then calculate the aspect ratio and define the corresponding --ar parameter accordingly) and quality (always ""--q 4"")

Your response must be a structured stock-ready output in valid JSON format, included the following fields:
""prompt"" ‚Äì prompt for MidJourney, version 7 ,take every detail into account and add creativity 
""title"" ‚Äì A short, descriptive, and engaging title (maximum 10 words).  
""category"" ‚Äì The most accurate image category based on standard stock taxonomy.  
""description"" ‚Äì A clear, medium-length description (2‚Äì3 sentences) that highlights the visual content, composition, colors, emotions, and possible commercial applications.  
""keywords"" ‚Äì An array of exactly 3 highly relevant, trend-aware, and stock-optimized keywords, including popular search terms like ""isolated"", ""copy space"", ""cut out"", ""flat lay"", ""top view"", ""minimalist"", ""authentic"", ""trendy"", ""vibrant colors"", ""clean design"", etc., depending on the image content.
";

    private string Response { get; set; } = string.Empty;
    private bool IsLoading { get; set; } = false;


    private async Task SendPrompt()
    {
        if (string.IsNullOrWhiteSpace(Prompt)) return;

        IsLoading = true;

        try
        {
            string _promtforgemmini = Prompt;

            if (!string.IsNullOrEmpty(SelectedFileInfo.MetadataForStock.Prompt))
            {
                _promtforgemmini = _promtforgemmini + "\n\n For better context, here is the prompt used to generate the image:" + SelectedFileInfo.MetadataForStock.Prompt;
            }

            var resultDict = await Gemini.GetImageInfo(SelectedFileInfo, _promtforgemmini);
            await Task.Delay(1000);

            SelectedFileInfo.MetadataForStock.Headline = resultDict.GetValueOrDefault("title").ToString();
            SelectedFileInfo.MetadataForStock.Keywords = resultDict.GetValueOrDefault("keywords").ToString();
            SelectedFileInfo.MetadataForStock.Caption = resultDict.GetValueOrDefault("description").ToString();
            //SelectedFileInfo.MetadataForStock.Category = Int32.Parse(resultDict.GetValueOrDefault("category").ToString());
            // SelectedFileInfo.MetadataForStock.CategoryName = resultDict.GetValueOrDefault("categoryName").ToString();
            SelectedFileInfo.MetadataForStock.Prompt = resultDict.GetValueOrDefault("prompt").ToString();

//   string json = await Gemini.GetAnswer(filePath, apiKey, Prompt);
//resultDict = await Gemini.GetAnswerD(filePath, apiKey, Prompt);

// Response = json;
        }
        catch (Exception ex)
        {
            ButtonClickMessage = $"‚ùå –ü–æ–º–∏–ª–∫–∞: {ex.Message}";
            StateHasChanged();
        }
        finally
        {
            IsLoading = false;
        }
    }

/*private async Task HandleSelectedFiles(InputFileChangeEventArgs e)
{
    Console.WriteLine("üîµ HandleSelectedFiles —Å—Ç–∞—Ä—Ç—É–≤–∞–≤");

    isUploading = true;
    processing = false;
    archiveReady = false;
    progress = 0;
    hasError = false;
    StateHasChanged();


    List<IBrowserFile> files;
    try
    {
        files = e.GetMultipleFiles(1000).ToList();
    }
    catch (Exception ex)
    {
        hasError = true;
        Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Ñ–∞–π–ª—ñ–≤: {ex.Message}");
        isUploading = false;
        StateHasChanged();
        return;
    }

    // –û–±–º–µ–∂–µ–Ω–Ω—è –Ω–∞ –∑–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
    long totalSize = files.Sum(f => f.Size);
    const long maxTotalSize = 2L * 1024 * 1024 * 1024; //2GB
    if (totalSize > maxTotalSize)
    {
        hasError = true;
        isUploading = false;
        Console.WriteLine("‚ùå –ó–∞–≥–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä –ø–µ—Ä–µ–≤–∏—â—É—î 1 GB");
        StateHasChanged();
        return;
    }

    var client = ClientFactory.CreateClient("serverAPI");

    try
    {
        var batches = files.Chunk(10).ToList();
        int currentFile = 0;

        foreach (var batch in batches)
        {
            Console.WriteLine("üîµ HandleSelectedFiles –æ–±—Ä–æ–±–ª—é—î –±–∞—Ç—á");

            using var content = new MultipartFormDataContent();

            foreach (var file in batch)
            {
                await using var stream = file.OpenReadStream(1024 * 1024 * 50); // –¥–æ 50MB
                var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                memoryStream.Position = 0;

                var streamContent = new StreamContent(memoryStream);
                streamContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);
                content.Add(streamContent, "files", file.Name);
            }

            Console.WriteLine("‚û°Ô∏è –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –±–∞—Ç—á—É...");
            var response = await client.PostAsync("api/archive/upload", content);

            if (!response.IsSuccessStatusCode)
            {
                Console.WriteLine($"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –±–∞—Ç—á—É: {response.StatusCode}");
                hasError = true;
                return;
            }

            var raw = await response.Content.ReadAsStringAsync();
            if (!Guid.TryParse(raw.Trim('"'), out uploadId))
            {
                Console.WriteLine("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ GUID");
                hasError = true;
                return;
            }

            currentFile += batch.Count();
            progress = (int)((double)currentFile / files.Count * 100);

            Console.WriteLine($"‚úÖ –ë–∞—Ç—á –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. UploadId: {uploadId}, –ü—Ä–æ–≥—Ä–µ—Å: {progress}%");
            StateHasChanged();
        }

        processing = true;
        Console.WriteLine("üü¢ –ß–µ–∫–∞—î–º–æ –Ω–∞ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –∞—Ä—Ö—ñ–≤—É...");
        await WaitForArchiveReady(uploadId);
    }
    catch (Exception ex)
    {
        hasError = true;
        Console.WriteLine($"‚ùå –í–∏–Ω—è—Ç–æ–∫: {ex.Message}");
    }
    finally
    {
        isUploading = false;
        StateHasChanged();
    }
}*/


}

<style>
    .preview-img {
        width: 100%;
        max-height: 150px;
        max-width: 150px;
        object-fit: cover;
        border: 2px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        cursor: pointer;
    }
    .thumbnail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 10px;
        margin-top: 1rem;
    }
</style>